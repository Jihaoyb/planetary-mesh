# 0003 – Job Model and /jobs API v0

- Status: Accepted
- Date: 2025-11-30

## Context

Planetary Mesh has a coordinator and agents:

- The coordinator tracks nodes and their health.
- Agents register with the coordinator and send heartbeats.
- The architecture document describes jobs, tasks, and scheduling in general terms.

To make the system useful and testable, we need a way for clients to:

- Submit units of work ("jobs") to the coordinator.
- Inspect those jobs and their status.

At this stage we are **not** yet executing jobs on agents; we only need a minimal job representation and a simple API.

Constraints and goals:

- Keep the implementation simple and in-memory for now.
- Provide a stable shape for jobs so that future features (execution, retries, UI) can build on it.
- Use plain HTTP + JSON for the public API in v0.

## Decision

1. **Job model (v0)**

   We introduce a `Job` type in the coordinator with the following fields:

   - `ID` – string identifier generated by the coordinator (e.g. `job-1`, `job-2`, …).
   - `Type` – string describing the job type (e.g. `"echo"`, `"script"`, etc.).
   - `Payload` – opaque string payload; interpretation is left to the agent or future layers.
   - `Status` – enum with initial values:
     - `QUEUED`
     - `RUNNING`
     - `COMPLETED`
     - `FAILED`
   - `CreatedAt` – timestamp when the job was created.
   - `UpdatedAt` – timestamp when the job was last updated.

   For v0 only `QUEUED` is used; additional statuses are defined now to avoid reshaping the model later.

2. **JobStore**

   The coordinator owns an in-memory `JobStore` with:

   - `Create(type, payload) Job`
     - Allocates a new job ID.
     - Sets `Status = QUEUED`.
     - Sets `CreatedAt` and `UpdatedAt` to the current time.
     - Stores the job in memory and returns a copy.
   - `List() []Job`
     - Returns a slice of job copies for all known jobs.

   Internally, `JobStore` uses:

   - A `map[string]*Job` protected by a `sync.Mutex`.
   - A simple counter (e.g., `nextID`) to generate IDs like `job-1`, `job-2`, etc.

   Returning copies rather than pointers ensures that callers cannot mutate internal state without going through the store.

3. **/jobs API (coordinator)**

   We expose a minimal HTTP API on the coordinator:

   - `POST /jobs`
     - Request JSON:
       - `type` (string, required).
       - `payload` (string, optional).
     - Behavior:
       - Validates input.
       - Calls `JobStore.Create(type, payload)`.
       - Returns `201 Created` with the job JSON body.

   - `GET /jobs`
     - Returns a JSON array of all known jobs as returned by `JobStore.List()`.

   The API uses plain HTTP + JSON as described in `tech-choices.md` and is suitable for CLI tools or a simple dashboard.

4. **No execution or scheduling yet**

   In this ADR we explicitly **do not** define:

   - How jobs are scheduled onto agents.
   - How job status transitions through `RUNNING` / `COMPLETED` / `FAILED`.

   Those behaviors are defined separately in ADR 0004 (Job Execution v1).

## Consequences

- Clients can now create jobs and list them via a stable HTTP API.
- The job model is simple but already anticipates future states (`RUNNING`, `COMPLETED`, `FAILED`).
- State is in-memory; restarting the coordinator loses jobs. This is acceptable for early development and LAN demos.
- Future changes (e.g. persistent DB, richer payload types, per-job metadata) will either:
  - Extend the existing `Job` shape, or
  - Be recorded in new ADRs if they introduce non-trivial tradeoffs.

- The existence of this ADR helps future contributors understand:
  - Why jobs are modeled the way they are.
  - Why we started with in-memory storage and HTTP + JSON.
  - Where job execution behavior is defined (ADR 0004).
